import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import type { AIConfig, AIProvider, TokenUsageRecord, GenerateResult } from '@/types'
import * as aiApi from '@/services/api/aiApi'

export const useAiStore = defineStore('ai', () => {
  // 状态
  const configs = ref<AIConfig[]>([])
  const currentConfig = ref<AIConfig | null>(null)
  const loading = ref(false)
  const error = ref<string | null>(null)
  const usageRecords = ref<TokenUsageRecord[]>([])
  const generating = ref(false)
  const generatedContent = ref('')
  // 生成步骤定义
  interface GenerationStep {
    id: string
    name: string
    description: string
    status: 'pending' | 'running' | 'completed'
  }
  // 生成进度（用于分步生成章节）
  const generatingProgress = ref({
    current: 0,      // 当前步骤索引 (0-4)
    total: 5,        // 总步骤数
    stage: '',       // 当前阶段名称
    steps: [
      { id: 'context', name: '加载上下文', description: '', status: 'pending' as const },
      { id: 'character', name: '角色分析', description: '', status: 'pending' as const },
      { id: 'scene', name: '场景理解', description: '', status: 'pending' as const },
      { id: 'logic', name: '逻辑检查', description: '', status: 'pending' as const },
      { id: 'generate', name: '内容生成', description: '', status: 'pending' as const }
    ] as GenerationStep[]
  })
  // 推理/思考过程（GLM-4.7等推理模型返回）
  const currentReasoning = ref<string | null>(null)
  // 嵌入式思考面板是否可见（用于控制浮窗是否显示）
  const embeddedPanelVisible = ref(false)

  // 计算属性
  const defaultConfig = computed(() =>
    configs.value.find(c => c.isDefault) || null
  )

  const configsByProvider = computed(() => {
    const grouped: Record<AIProvider, AIConfig[]> = {
      openai: [],
      claude: [],
      qianwen: [],
      wenxin: [],
      zhipu: [],
      gemini: [],
      ollama: [],
      custom: []
    }
    configs.value.forEach(config => {
      grouped[config.provider].push(config)
    })
    return grouped
  })

  const totalTokensUsed = computed(() =>
    usageRecords.value.reduce((sum, r) => sum + r.totalTokens, 0)
  )

  const totalCost = computed(() =>
    usageRecords.value.reduce((sum, r) => sum + r.estimatedCost, 0)
  )

  const hasConfig = computed(() => configs.value.length > 0)

  // 方法
  async function fetchConfigs(): Promise<void> {
    loading.value = true
    error.value = null
    try {
      configs.value = await aiApi.getAIConfigs()
      // 设置当前配置为默认配置
      if (!currentConfig.value && defaultConfig.value) {
        currentConfig.value = defaultConfig.value
      }
    } catch (e) {
      error.value = e instanceof Error ? e.message : '获取AI配置失败'
    } finally {
      loading.value = false
    }
  }

  async function createConfig(input: aiApi.CreateAIConfigInput): Promise<AIConfig | null> {
    loading.value = true
    error.value = null
    try {
      const config = await aiApi.createAIConfig(input)
      configs.value.push(config)
      // 如果是默认配置，更新其他配置
      if (config.isDefault) {
        configs.value.forEach(c => {
          if (c.id !== config.id) {
            c.isDefault = false
          }
        })
      }
      return config
    } catch (e) {
      error.value = e instanceof Error ? e.message : '创建AI配置失败'
      return null
    } finally {
      loading.value = false
    }
  }

  async function updateConfig(id: string, input: aiApi.UpdateAIConfigInput): Promise<AIConfig | null> {
    loading.value = true
    error.value = null
    try {
      const config = await aiApi.updateAIConfig(id, input)
      const index = configs.value.findIndex(c => c.id === id)
      if (index >= 0) {
        configs.value[index] = config
      }
      // 如果设置为默认配置，更新其他配置
      if (config.isDefault) {
        configs.value.forEach(c => {
          if (c.id !== config.id) {
            c.isDefault = false
          }
        })
      }
      return config
    } catch (e) {
      error.value = e instanceof Error ? e.message : '更新AI配置失败'
      return null
    } finally {
      loading.value = false
    }
  }

  async function deleteConfig(id: string): Promise<boolean> {
    loading.value = true
    error.value = null
    try {
      await aiApi.deleteAIConfig(id)
      configs.value = configs.value.filter(c => c.id !== id)
      if (currentConfig.value?.id === id) {
        currentConfig.value = defaultConfig.value
      }
      return true
    } catch (e) {
      error.value = e instanceof Error ? e.message : '删除AI配置失败'
      return false
    } finally {
      loading.value = false
    }
  }

  async function setDefault(id: string): Promise<boolean> {
    loading.value = true
    error.value = null
    try {
      await aiApi.setDefaultAIConfig(id)
      configs.value.forEach(c => {
        c.isDefault = c.id === id
      })
      return true
    } catch (e) {
      error.value = e instanceof Error ? e.message : '设置默认配置失败'
      return false
    } finally {
      loading.value = false
    }
  }

  async function testConnection(id: string): Promise<boolean> {
    loading.value = true
    error.value = null
    try {
      return await aiApi.testAIConfigConnection(id)
    } catch (e) {
      error.value = e instanceof Error ? e.message : '测试连接失败'
      return false
    } finally {
      loading.value = false
    }
  }

  async function getModels(id: string): Promise<string[]> {
    try {
      return await aiApi.getAvailableModels(id)
    } catch (e) {
      console.error('获取模型列表失败:', e)
      return []
    }
  }

  function setCurrentConfig(config: AIConfig | null): void {
    currentConfig.value = config
  }

  function addUsageRecord(record: TokenUsageRecord): void {
    usageRecords.value.push(record)
  }

  // AI生成相关方法
  async function generate(request: aiApi.GenerateRequest): Promise<GenerateResult | null> {
    generating.value = true
    error.value = null
    generatedContent.value = ''
    currentReasoning.value = null
    try {
      const result = await aiApi.generate(request)
      generatedContent.value = result.content
      // 保存推理过程（如果有）
      if (result.reasoning) {
        currentReasoning.value = result.reasoning
      }
      return result
    } catch (e) {
      error.value = e instanceof Error ? e.message : '生成失败'
      return null
    } finally {
      generating.value = false
    }
  }

  async function continueWriting(request: aiApi.ContinueWritingRequest): Promise<GenerateResult | null> {
    generating.value = true
    error.value = null
    generatedContent.value = ''
    currentReasoning.value = null
    try {
      const result = await aiApi.continueWriting(request)
      generatedContent.value = result.content
      // 续写正文时不需要显示推理过程，直接输出正文
      return result
    } catch (e) {
      error.value = e instanceof Error ? e.message : '续写失败'
      return null
    } finally {
      generating.value = false
    }
  }

  async function generateOutline(request: aiApi.GenerateOutlineRequest): Promise<GenerateResult | null> {
    generating.value = true
    error.value = null
    generatedContent.value = ''
    currentReasoning.value = null
    try {
      const result = await aiApi.generateOutline(request)
      generatedContent.value = result.content
      if (result.reasoning) {
        currentReasoning.value = result.reasoning
      }
      return result
    } catch (e) {
      error.value = e instanceof Error ? e.message : '生成大纲失败'
      return null
    } finally {
      generating.value = false
    }
  }

  async function chat(request: aiApi.ChatRequest): Promise<GenerateResult | null> {
    generating.value = true
    error.value = null
    currentReasoning.value = null
    try {
      const result = await aiApi.chat(request)
      if (result.reasoning) {
        currentReasoning.value = result.reasoning
      }
      return result
    } catch (e) {
      error.value = e instanceof Error ? e.message : '对话失败'
      return null
    } finally {
      generating.value = false
    }
  }

  // 清除推理内容
  function clearReasoning(): void {
    currentReasoning.value = null
  }

  // 更新生成步骤状态
  function updateStep(stepId: string, status: 'pending' | 'running' | 'completed', description?: string): void {
    const step = generatingProgress.value.steps.find(s => s.id === stepId)
    if (step) {
      step.status = status
      if (description !== undefined) {
        step.description = description
      }
      // 更新当前步骤索引
      const completedCount = generatingProgress.value.steps.filter(s => s.status === 'completed').length
      generatingProgress.value.current = completedCount
      // 更新当前阶段名称
      const runningStep = generatingProgress.value.steps.find(s => s.status === 'running')
      generatingProgress.value.stage = runningStep?.name || ''
    }
  }

  // 更新生成进度（兼容旧方法）
  function updateProgress(current: number, stage: string): void {
    generatingProgress.value.current = current
    generatingProgress.value.stage = stage
  }

  // 重置生成进度
  function resetProgress(): void {
    generatingProgress.value.current = 0
    generatingProgress.value.stage = ''
    generatingProgress.value.steps.forEach(step => {
      step.status = 'pending'
      step.description = ''
    })
  }

  return {
    // 状态
    configs,
    currentConfig,
    loading,
    error,
    usageRecords,
    generating,
    generatedContent,
    generatingProgress,
    currentReasoning,
    embeddedPanelVisible,
    // 计算属性
    defaultConfig,
    configsByProvider,
    totalTokensUsed,
    totalCost,
    hasConfig,
    // 配置管理方法
    fetchConfigs,
    createConfig,
    updateConfig,
    deleteConfig,
    setDefault,
    testConnection,
    getModels,
    setCurrentConfig,
    addUsageRecord,
    // AI生成方法
    generate,
    continueWriting,
    generateOutline,
    chat,
    clearReasoning,
    updateStep,
    updateProgress,
    resetProgress
  }
})
